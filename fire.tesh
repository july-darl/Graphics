#version 450 core
layout (triangles, equal_spacing, ccw) in;

uniform mat4 ModelMatrix;
uniform mat4 IT_ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectMatrix;
uniform float time;
uniform sampler2D perlin;
uniform vec3 windDir;

in vec2 c_texcoord[gl_MaxPatchVertices];
in vec3 c_normal[gl_MaxPatchVertices];
in vec3 c_tangent[gl_MaxPatchVertices];

out vec2 v_texcoord;
out vec3 v_normal;
out vec3 v_tangent;
out vec2 v_depth;
out vec3 v_worldPos;

vec3 interpolate3D(vec3 v0, vec3 v1, vec3 v2)
{
    return vec3(gl_TessCoord.x) * v0 + vec3(gl_TessCoord.y) * v1 + vec3(gl_TessCoord.z) * v2;
}

vec2 interpolate2D(vec2 v0, vec2 v1, vec2 v2)
{
    return vec2(gl_TessCoord.x) * v0 + vec2(gl_TessCoord.y) * v1 + vec2(gl_TessCoord.z) * v2;
}

float interpolate1D(float v0, float v1, float v2)
{
    return (gl_TessCoord.x) * v0 + (gl_TessCoord.y) * v1 + (gl_TessCoord.z) * v2;
}

void main(void)
{

    vec4 pos = gl_in[0].gl_Position * gl_TessCoord.x +
               gl_in[1].gl_Position * gl_TessCoord.y +
               gl_in[2].gl_Position * gl_TessCoord.z;

    vec3 normal = interpolate3D(c_normal[0],c_normal[1],c_normal[2]);
    vec3 tangent = interpolate3D(c_tangent[0],c_tangent[1],c_tangent[2]);

    mat3 M1 = mat3(IT_ModelMatrix[0].xyz, IT_ModelMatrix[1].xyz, IT_ModelMatrix[2].xyz);
    v_normal = normalize(M1 * normal);

    mat3 M2 = mat3(ModelMatrix[0].xyz, ModelMatrix[1].xyz, ModelMatrix[2].xyz);
    v_tangent = normalize(M2 * tangent);


    v_texcoord = interpolate2D(c_texcoord[0],c_texcoord[1],c_texcoord[2]);

    gl_Position = ModelMatrix * pos;
    v_worldPos = gl_Position.xyz/gl_Position.w;

    vec3 worldPos = v_worldPos;
    float ratio = dot(v_normal,windDir);
    if(ratio > 0.5)
    {
        float offset = texture(perlin,v_texcoord + time).r;
        offset = clamp((offset - 0.5) / (1 - 0.5),0,1);
        worldPos += windDir * 0.5 * offset;
    }

    gl_Position = ViewMatrix * vec4(worldPos,1);

    v_depth = gl_Position.zw;
    gl_Position = ProjectMatrix * gl_Position;
}
